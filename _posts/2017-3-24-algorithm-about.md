---
layout: post
title: iOSè£…13-ä¹‹æ•°æ®ç»“æ„ä¸ç®—æ³•
---

## å…¨æ ˆ æ•°æ®ç»“æ„ä¸ç®—æ³•

å…ˆä¸Šå›¾
![æç¬‘](https://raw.githubusercontent.com/QuanGe/QuanGe.github.io/master/images/just_do_it.png)

çœ‹åˆ°ä¸Šå›¾æœ‰ä»€ä¹ˆæ„Ÿæ…¨ï¼Ÿæ˜¯ä¸æ˜¯å¾ˆå†²åŠ¨ã€‚å¦‚æœåªæ˜¯å¹²ï¼Œä¸æ€è€ƒï¼Œé‚£æˆ‘ä»¬åˆä¸æœºå™¨æœ‰ä½•åˆ†åˆ«ï¼ˆè™½ç„¶åœ¨è€æ¿çœ¼é‡Œæˆ‘ç­‰çœŸçš„åªæ˜¯æœºå™¨ï¼‰ã€‚

é‚£ä¹ˆæ•°æ®ç»“æ„ä¸ç®—æ³•åˆ°åº•æœ‰å•¥ç”¨å‘¢ï¼Ÿè¿™å°±å¥½æ¯”å¤ä»£æ‰“ä»—ï¼Œæ•°æ®ç»“æ„å°±å¥½æ¯”æˆ‘ä»¬çš„å…µå™¨ï¼Œç®—æ³•å°±å¥½æ¯”æ˜¯æ‹›å¼ï¼Œå¦‚æœä½ ä¸¤è€…éƒ½æ²¡æœ‰å°±å¥½æ¯”æ™®é€šäººæ²¡æœ‰æ­¦åŠŸä¿®ä¸ºã€‚

æ¥æ¥æ¥ï¼Œå¤è¯æœ‰äº‘ï¼Œæ˜¯éª¡å­æ˜¯é©¬æ‹‰å‡ºæ¥æºœæºœï¼Œè€ä¸¤ä¸‹ç…ç…ã€‚

å¼€å§‹ä¹‹å‰å…ˆé—®è‡ªå·±å‡ ä¸ªé—®é¢˜

1ã€æ•°ç»„ä¸é“¾è¡¨çš„åŒºåˆ«ï¼Œä¸ºä»€ä¹ˆC++ä¹‹çˆ¶æœ¬è´¾å°¼Â·æ–¯ç‰¹åŠ³æ–¯ç‰¹å¢æ™®(Bjarne Stroustrup)è¯´è¦å°½é‡é¿å…ä½¿ç”¨é“¾è¡¨ï¼Ÿ

2ã€ä½ åœ¨å¹³å¸¸çš„ç¼–ç¨‹ä¸­å“ªäº›ç”¨åˆ°äº†æ ˆï¼Œå“ªäº›ç”¨åˆ°äº†é˜Ÿåˆ—ï¼Œå“ªé‡Œåˆç”¨åˆ°äº†äºŒå‰æ ‘

3ã€ä½ éƒ½çŸ¥é“æœ‰å“ªäº›æ’åºæ–¹æ³•ï¼Œå“ªäº›æ˜¯ç¨³å®šçš„æ’åºï¼Œè¯´è¯´å„ä¸ªæ–¹æ³•çš„å®ç°çš„æµç¨‹ã€‚

4ã€æ•£åˆ—ï¼ˆå­—å…¸ï¼‰ä¸­æŸ¥æ‰¾çš„æ—¶é—´å¤æ‚åº¦æ˜¯å¤šå°‘


#### å›å¿†å›å¿†

#### é“¾è¡¨

æ•°æ®ç»“æ„è¿™é—¨è¯¾è€å¸ˆç¬¬ä¸€ä¸ªå°†çš„è‚¯å®šæ˜¯é“¾è¡¨ï¼Œè€Œä¸”æ˜¯ä¸æ•°ç»„å¯¹æ¯”ç€æ¥è®²çš„ã€‚æˆ‘ä¹Ÿæ¥åˆ—ä¸¾ä¸€äºŒ

1ã€åˆ›å»ºï¼šä¸€èˆ¬åˆ›å»ºä¸€ä¸ªæ•°ç»„å¾ˆç®€å•ï¼Œæ¯”å¦‚int[5],è¿™ä¸ª5å°±æ˜¯æ•°æ®çš„å®¹é‡ï¼Œå¦‚æœæ•°ç»„æ»¡äº†ï¼Œè¿˜éœ€è¦å¢åŠ å…ƒç´ éœ€è¦æ‰©å®¹ã€‚è€Œé“¾è¡¨ä¸éœ€è¦æŒ‡å®šå®¹é‡ã€‚ä½†æ˜¯ï¼Œæ•°ç»„åœ¨å ç”¨å†…å­˜æ–¹é¢è¦æ¯”é“¾è¡¨è¦å°‘å“¦ï¼Œå› ä¸ºé“¾è¡¨è¦å®ç°ä¸€ä¸ªç»“æ„ä½“ï¼Œç»“æ„ä½“é‡Œé™¤äº†è¦æœ‰ä¸€ä¸ªæ•°æ®çš„å˜é‡è¿˜éœ€è¦ä¸€ä¸ªnextæŒ‡é’ˆã€‚
2ã€å¢ï¼šåœ¨æ•°ç»„ä¸­é—´æ’å…¥ä¸€æ¡æ•°æ®ï¼Œåé¢çš„è¦åç§»ã€‚åœ¨é“¾è¡¨ä¸­æ’å…¥ä¸€æ¡æ•°æ®ï¼Œè¦å…ˆæ‰¾åˆ°è¦æ’å…¥çš„ä½ç½®çš„å…ƒç´ ï¼Œç„¶åå°†nextçš„å…ƒç´ äº¤ç»™è¦æ’å…¥çš„å…ƒç´ ï¼Œç„¶åå†å°†è‡ªå·±çš„nextå…ƒç´ æŒ‡å‘è¦æ’å…¥çš„å…ƒç´ 
3ã€åˆ ï¼šå¤æ‚ç¨‹åº¦åŒä¸Š
4ã€æ”¹ï¼šæ•°ç»„ä¸­ä¿®æ”¹æŸä¸ªå€¼ç›´æ¥ä¿®æ”¹å°±å¥½ã€‚é“¾è¡¨è¦æ‰¾åˆ°è¯¥ä½ç½®çš„å…ƒç´ ï¼Œç„¶åå†ä¿®æ”¹ã€‚
5ã€æŸ¥ï¼šæ•°ç»„ç›´æ¥å¯ä»¥æ‹¿åˆ°æŸä½ç½®çš„å…ƒç´ ã€‚é“¾è¡¨è¦æŸ¥æ‰¾ã€‚
6ã€éå†ï¼šç”±äºæ•°ç»„çš„æ•°æ®éƒ½æ˜¯å­˜åœ¨è¿ç»­çš„å†…å­˜ï¼Œè€Œé“¾è¡¨çš„æ•°æ®æ¯”è¾ƒåˆ†æ•£ï¼Œæ‰€ä»¥åœ¨éå†çš„æ—¶å€™ï¼Œåœ¨CPUçš„æ€§èƒ½æ¥è®²ï¼Œæ•°ç»„æ›´èƒ½åˆ©ç”¨CPUçš„ç¼“å­˜(ä¸€èˆ¬ä¸€çº§ç¼“å­˜æ˜¯64k)æ¥è¿›è¡Œè®¡ç®—æ¥æé«˜æ€§èƒ½ã€‚è€Œé“¾è¡¨æ¯”è¾ƒåˆ†æ•£ï¼Œå¾ˆå¤§å‡ ç‡ä¸Šå°±ä¼šç”¨ä¸ä¸ŠCPUçš„ç¼“å­˜äº†ã€‚


ç”±ä¸Šé¢å¯è§ï¼Œé“¾è¡¨é™¤äº†åœ¨å®¹é‡æ–¹é¢æœ‰å¯å–ä¹‹å¤„å¤–ï¼Œæ²¡æœ‰ä»€ä¹ˆå¯ä»¥å¯å–çš„äº†ä¹ˆï¼ŸåŒå­¦ä½ éš¾é“å¿˜è®°äº†åŒå‘é“¾è¡¨äº†ä¹ˆï¼Ÿå¦å¤–ä½ å¿˜è®°äº†è¿˜æœ‰ä¸€ç§æ•°æ®ç»“æ„å«åšæ ‘å“¦ï¼Œå¯¹äºä¸æ˜¯äºŒå‰æ ‘çš„æ ‘ï¼Œæ•°ç»„æ˜¯ä¸èƒ½æ»¡è¶³è¦æ±‚çš„å“¦ã€‚æ‰€ä»¥æˆ‘ä»¬è¦å°½é‡é¿å…ä½¿ç”¨é“¾è¡¨ã€‚æ‰€ä»¥è¯´å½“ä½ æ”¾åœ¨å®¹å™¨ä¸­çš„æ•°æ®ä¹‹é—´æ²¡æœ‰ä»»ä½•å…³ç³»çš„æ—¶å€™ï¼Œæœ€å¥½é€‰æ‹©æ•°ç»„ã€‚

[C++ä¹‹çˆ¶çš„è§†é¢‘ç‚¹è¿™é‡Œ](http://v.youku.com/v_show/id_XNzE0ODM2NzUy.html#0-sqq-1-47421-9737f6f9e09dfaf5d3fd14d775bfee85)

#### æ ˆã€é˜Ÿåˆ—ã€äºŒå‰æ ‘

æ ˆï¼šå…ˆè¿›åå‡ºã€‚å¯ä»¥ç”¨æ•°ç»„å’Œé“¾è¡¨å®ç°.å¹³å¸¸ç”¨åˆ°çš„æ¯”å¦‚




### å¤§å­¦ç”¨Cè¯­è¨€å†™çš„mainå‡½æ•°é‡Œåªå†™äº†hello word ï¼Œé¢æœ‰çº¿ç¨‹ä¹ˆ

[In a non-concurrent application, there is only one thread of execution. That thread starts and ends with your applicationâ€™s main routine and branches one-by-one to different methods or functions to implement the applicationâ€™s overall behavior. ](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/AboutThreads/AboutThreads.html#//apple_ref/doc/uid/10000057i-CH6-SW2)

è¿™æ˜¯æ¥è‡ªè‹¹æœå®˜æ–¹æ–‡æ¡£ï¼Œä¹‹æ‰€ä»¥è¦æ‘˜è‡ªæ–‡æ¡£ï¼Œåªæƒ³è®©ç­”æ¡ˆæ›´æœ‰è¯´æœåŠ›ã€‚ä¹Ÿå°±æ˜¯å³ä½¿åªæœ‰ä¸€ä¸ªmainå‡½æ•°ä¹Ÿæ˜¯å­˜åœ¨çº¿ç¨‹çš„ã€‚

### CPUé¢‘ç‡å’Œä¸ªæ•°ä¸å¤šçº¿ç¨‹æœ‰ä»€ä¹ˆå…³ç³»

ç›®å‰CPUçš„é¢‘ç‡å·²ç»è¾¾åˆ°äº†ä¸€ä¸ªæé™ï¼Œå¾ˆéš¾åœ¨æŠ€æœ¯ä¸Šæœ‰å¾ˆé«˜çš„çªç ´ï¼Œäºæ˜¯äººä»¬å¼€å§‹å‘å¤šæ ¸å‘å±•ã€‚å½“åªæœ‰ä¸€ä¸ªCPUçš„æ—¶å€™ä¸å­˜åœ¨çœŸæ­£æ„ä¹‰ä¸Šçš„å¤šçº¿ç¨‹ï¼Œåªä¸è¿‡æ˜¯CPUåœ¨å„ä¸ªçº¿ç¨‹ä¸åœçš„åˆ‡æ¢ï¼Œåˆ‡æ¢çš„é¢‘ç‡å³CPUçš„é¢‘ç‡ã€‚å¤šä¸ªCPUæ‰æ˜¯çœŸæ­£çš„å¤šçº¿ç¨‹


### è¿›ç¨‹å’Œçº¿ç¨‹çš„å…³ç³»

çº¿ç¨‹æ˜¯CPUè°ƒåº¦çš„åŸºæœ¬å•ä½ï¼Œä¸€ä¸ªè¿›ç¨‹è‡³å°‘åŒ…å«ä¸€ä¸ªçº¿ç¨‹ã€‚Linuxå†…æ ¸ä¸­å¹¶ä¸å­˜åœ¨çœŸæ­£æ„ä¹‰ä¸Šçš„çº¿ç¨‹æ¦‚å¿µï¼Œæ‰€æœ‰çš„æ‰§è¡Œå®ä½“éƒ½ç§°ä¸ºä»»åŠ¡ï¼ˆTaskï¼‰ï¼Œæ¯ä¸ªäººç‰©æ¦‚å¿µä¸Šéƒ½ç±»ä¼¼äºä¸€ä¸ªå•çº¿ç¨‹çš„è¿›ç¨‹ï¼Œå…·æœ‰å†…å­˜ç©ºé—´ã€æ‰§è¡Œå®ä½“ã€æ–‡ä»¶èµ„æºï¼Œä¸è¿‡Linuxä¸‹ä¸åŒçš„äººç‰©ä¹‹é—´å¯ä»¥é€‰æ‹©å…±äº«å†…å­˜ç©ºé—´ã€‚å› æ­¤å…±äº«äº†åŒä¸€ä¸ªå†…å­˜ç©ºé—´çš„å¤šä¸ªä»»åŠ¡æ„æˆäº†ä¸€ä¸ªè¿›ç¨‹ï¼Œè¿™äº›ä»»åŠ¡ä¹Ÿå°±æˆäº†è¿›ç¨‹é‡Œçš„çº¿ç¨‹ã€‚å¦å¤–ä¸€ä¸ªç¨‹åºå¯èƒ½åŒ…å«å¤šä¸ªè¿›ç¨‹ã€‚å¯ä»¥åœ¨macé‡Œæ‰§è¡Œ `ps aux |grep Xcode`æŸ¥çœ‹Xcodeè¿è¡Œäº†å¤šä¸ªè¿›ç¨‹

### çº¿ç¨‹çš„è®¿é—®æƒé™ ï¼Œå®ƒéƒ½å¯ä»¥è®¿é—®å“ªäº›ä¸œè¥¿

æ¯ä¸ªçº¿ç¨‹éƒ½æœ‰è‡ªå·±çš„æ ˆï¼ˆå°½ç®¡å¹¶éå®Œå…¨æ— æ³•è¢«å…¶å®ƒçº¿ç¨‹è®¿é—®ï¼Œä½†æ˜¯ä¸€èˆ¬æƒ…å†µä¸‹ä»ç„¶å¯ä»¥è®¤ä¸ºæ˜¯ç§æœ‰çš„æ•°æ®ï¼‰ã€å¯„å­˜å™¨ï¼ˆæ‰§è¡Œæµçš„åŸºæœ¬æ•°æ®ï¼Œå› æ­¤ä¸ºçº¿ç¨‹ç§æœ‰ï¼‰å’Œçº¿ç¨‹å±€éƒ¨å­˜å‚¨(Thread Local Storage,TLS )ã€‚å› æ­¤ä»ä»£ç ä¸Šæ¥çœ‹ï¼Œçº¿ç¨‹ç§æœ‰çš„æœ‰ï¼šå±€éƒ¨å˜é‡ã€å‡½æ•°çš„å‚æ•°ã€TLSæ•°æ®ã€‚çº¿ç¨‹é—´å…±æœ‰çš„æœ‰ï¼šå…¨å±€å˜é‡ã€å †ä¸Šçš„æ•°æ®ã€å‡½æ•°é‡Œçš„é™æ€å˜é‡ã€æ‰“å¼€çš„æ–‡ä»¶ï¼ˆAçº¿ç¨‹æ‰“å¼€çš„æ–‡ä»¶å¯ä»¥ç”±Bçº¿ç¨‹è¯»å†™ï¼‰

[å®˜æ–¹æ–‡æ¡£ä¸­TLS](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/CreatingThreads/CreatingThreads.html#//apple_ref/doc/uid/10000057i-CH15-SW2)

<blockquote>
> Configuring Thread-Local Storage
> Each thread maintains a dictionary of key-value pairs that can be accessed from anywhere in the thread. You can use this dictionary to store information that you want to persist throughout the execution of your thread. For example, you could use it to store state information that you want to persist through multiple iterations of your threadâ€™s run loop.

> Cocoa and POSIX store the thread dictionary in different ways, so you cannot mix and match calls to the two technologies. As long as you stick with one technology inside your thread code, however, the end results should be similar. In Cocoa, you use the threadDictionary method of an NSThread object to retrieve an NSMutableDictionary object, to which you can add any keys required by your thread. In POSIX, you use the pthread_setspecific and pthread_getspecific functions to set and get the keys and values of your thread.

</blockquote>
### çº¿ç¨‹åŒæ­¥ éƒ½æœ‰å“ªå‡ ç§é”

##### ä¿¡å·é‡ (Semaphore)

ä¿¡å·é‡åˆåˆ†ä¸ºäºŒå…ƒä¿¡å·é‡ å’Œå¤šå…ƒä¿¡å·é‡ã€‚äºŒå…ƒä¿¡å·é‡æ˜¯æœ€ç®€å•çš„ä¸€ç§é”ï¼Œå®ƒåªæœ‰ä¸¤ç§çŠ¶æ€ï¼šå ç”¨å’Œéå ç”¨ã€‚å®ƒé€‚åˆåªèƒ½è¢«å”¯ä¸€ä¸€ä¸ªçº¿ç¨‹ç‹¬å è®¿é—®çš„èµ„æºã€‚å½“äºŒå…ƒä¿¡å·é‡å¤„äºéå ç”¨çš„çŠ¶æ€æ—¶ï¼Œç¬¬ä¸€ä¸ªè¯•å›¾è·å–è¯¥äºŒå…ƒä¿¡å·é‡çš„çº¿ç¨‹ä¼šè·å¾—è¯¥é”ï¼Œå¹¶å°†äºŒå…ƒä¿¡å·é‡ä¹‹ä¸ºå ç”¨çŠ¶æ€ï¼Œæ­¤åå…¶å®ƒæ‰€æœ‰è¯•å›¾è·å–è¯¥äºŒå…ƒä¿¡å·é‡çš„æ–°åŸå°†ä¼šç­‰å¾…ï¼Œç›´åˆ°è¯¥é”è¢«é‡Šæ”¾ã€‚å¤šå…ƒä¿¡å·é‡ä¼šæœ‰ä¸€ä¸ªNå€¼ï¼Œè·å–ä¿¡å·é‡åNå‡ä¸€ï¼Œå¦‚æœNå°äº0åˆ™ç­‰å¾…ã€‚è®¿é—®èµ„æºåçº¿ç¨‹é‡Šæ”¾ä¿¡å·é‡NåŠ 1ï¼Œå¦‚æœNå°äº1ï¼Œå”¤é†’ä¸‹ä¸€ä¸ªç­‰å¾…çš„çº¿ç¨‹

##### äº’æ–¥é‡ ï¼ˆMutexï¼‰

äº’æ–¥é‡å’ŒäºŒå…ƒä¿¡å·é‡ç›¸ä¼¼ï¼Œä¸åŒçš„æ˜¯ä¿¡å·é‡åœ¨æ•´ä¸ªç³»ç»Ÿä¸­å¯ä»¥è¢«ä»»æ„çº¿ç¨‹è·å–å¹¶é‡Šæ”¾ï¼Œè€Œäº’æ–¥é‡åˆ™æœ‰æ±‚é‚£ä¸ªçº¿ç¨‹è·å–äº†äº’æ–¥é‡ï¼Œå“ªä¸ªçº¿ç¨‹å°±è¦è´Ÿè´£é‡Šæ”¾è¿™ä¸ªé”ï¼Œå…¶å®ƒçº¿ç¨‹æƒ³å»é‡Šæ”¾æ˜¯ä¸è¡Œçš„ã€‚

##### ä¸´ç•ŒåŒº ï¼ˆCritical Sectionï¼‰

ä¸´ç•ŒåŒºæ˜¯æ¯”äº’æ–¥é‡æ›´åŠ ä¸¥æ ¼çš„åŒæ­¥æ‰‹æ®µï¼Œåœ¨æœ¯è¯­ä¸­æŠŠä¸´ç•ŒåŒºçš„é”çš„è·å–ç§°ä¸ºè¿›å…¥ä¸´ç•ŒåŒºï¼Œè€ŒæŠŠé”çš„é‡Šæ”¾ç§°ä¸ºç¦»å¼€ä¸´ç•ŒåŒºã€‚å®ƒä¸äº’æ–¥é‡å’Œä¿¡å·é‡çš„åŒºåˆ«åœ¨äºï¼Œäº’æ–¥é‡å’Œä¿¡å·é‡åœ¨ç³»ç»Ÿçš„çš„ä»»ä½•è¿›ç¨‹éƒ½æ˜¯å¯è§çš„ï¼Œä¹Ÿå°±æ˜¯è¯´ä¸€ä¸ªè¿›ç¨‹åˆ›å»ºäº†ä¸€ä¸ªäº’æ–¥é‡å’Œä¿¡å·é‡ï¼Œå¦ä¸€ä¸ªè¿›ç¨‹è¯•å›¾å»è·å–è¯¥é”æ˜¯åˆæ³•çš„ã€‚è€Œä¸´ç•ŒåŒºçš„ä½œç”¨èŒƒå›´ä»…é™äºæœ¬è¿›ç¨‹ã€‚å…¶å®ƒè¿›ç¨‹æ— æ³•è·å–è¯¥é”ã€‚é™¤æ­¤ä¹‹å¤–ï¼Œä¸´ç•ŒåŒºå…·æœ‰å’Œäº’æ–¥é‡ç›¸åŒçš„æ€§è´¨ã€‚

##### è¯»å†™é” (Read-Write Lock)

å¯¹äºä¸€æ®µæ•°æ®ï¼Œå¤šä¸ªçº¿ç¨‹è¯»å†™é¢‘ç¹ï¼Œä½†æ˜¯ä»…ä»…å¶å°”å†™å…¥ï¼Œå¦‚æœç”¨ä»¥ä¸Šå‡ ç§é”å°±ä¼šéå¸¸ä½æ•ˆï¼Œç”¨è¯»å†™é”æ›´å¿«ä¸€ç‚¹ã€‚è¯»å†™é”çš„è·å–åˆåˆ†ä¸ºå…±äº«çš„ï¼ˆSharedï¼‰æˆ–ç‹¬å çš„ï¼ˆExclusiveï¼‰ï¼Œçœ‹å­—é¢æ„æ€ä¹Ÿèƒ½çŒœä¸ªå¤§æ¦‚ï¼Œå°±ä¸è§£é‡Šäº†ã€‚

##### æ¡ä»¶å˜é‡ ï¼ˆCondition Variableï¼‰

ä½œç”¨ç±»ä¼¼äºæ …æ ï¼Œä½¿ç”¨æ¡ä»¶å˜é‡å¯ä»¥ä½¿è®¸å¤šçº¿ç¨‹ä¸€èµ·ç­‰å¾…æŸä¸ªäº‹ä»¶çš„å‘ç”Ÿï¼Œå½“äº‹ä»¶å‘ç”Ÿæ—¶ï¼ˆæ¡ä»¶å˜é‡è¢«å”¤é†’ï¼‰ï¼Œæ‰€æœ‰çš„çº¿ç¨‹å¯ä»¥ä¸€èµ·æ¢å¤æ‰§è¡Œã€‚

### çº¿ç¨‹ä¸­éƒ½æœ‰å“ªäº›å‘éœ€è¦æ³¨æ„

çº¿ç¨‹å®‰å…¨æ¯”è¾ƒéš¾æï¼Œå› ä¸ºä½ å³ä½¿åˆç†ç”¨äº†é”ï¼Œä¹Ÿä¸ä¸€å®šèƒ½ä¿è¯çº¿ç¨‹å®‰å…¨ã€‚åŸå› æœ‰ä¸‰ï¼š

1ã€ç¼–è¯‘å™¨ä¼šä¸ºäº†æé«˜é€Ÿåº¦å°†ä¸€ä¸ªå˜é‡ç¼“å­˜åˆ°å¯„å­˜å™¨ä¸­è€Œä¸å†™å›

2ã€ç¼–è¯‘å™¨ä¼šåœ¨è¿›è¡Œä¼˜åŒ–çš„æ—¶å€™ä¸ºäº†æ•ˆç‡äº¤æ¢æ¯«ä¸ç›¸å¹²çš„ä¸¤æ¡ç›¸é‚»æŒ‡ä»¤çš„æ‰§è¡Œé¡ºåº

3ã€æ—©åœ¨å‡ åå¹´å‰ï¼ŒCPUå°±å‘å±•å‡ºäº†åŠ¨æ€è°ƒåº¦ï¼Œä¸ºäº†æ‰§è¡Œç¨‹åºçš„æ—¶å€™ä¸ºäº†æé«˜æ•ˆç‡æœ‰å¯èƒ½äº¤æ¢æŒ‡ä»¤çš„é¡ºåº

è§£å†³1ç”¨volatileï¼Œè§£å†³åä¸¤è€…ç”¨barrier

## ä»AFNetworkingçœ‹ä¸Šé¢iOSé‡Œé¢çš„å¤šçº¿ç¨‹

[iOSå„ç§å¤šçº¿ç¨‹çš„ä»‹ç»ç‚¹æˆ‘](http://quangelab.com/iOS-NSThread-GCD-NSOperation)

æˆ‘ä»¬ä¸»è¦çœ‹å¤šçº¿ç¨‹ç›¸å…³ æ‰€ä»¥è¯·å°†AFNetworkingåˆ‡æ¢åˆ°2.xåˆ†æ”¯ï¼Œå°½ç®¡NSURLConnectionå·²ç»åœ¨iOS9.0åœç”¨äº†ï¼Œbutæˆ‘ä»¬åªå…³æ³¨å¤šçº¿ç¨‹ã€‚

æˆ‘ä»¬çŸ¥é“å®ç°å¤šçº¿ç¨‹ä¸»è¦æœ‰NSThreadã€POSIXï¼ˆpthreadï¼‰ã€NSOperationã€GCDã€‚è€ŒNSThreadã€NSOperationã€GCDéƒ½æ˜¯ç”±pthreadå®ç°ï¼Œåªä¸è¿‡å®ƒä»¬çš„ä½¿ç”¨æ–¹æ³•å„æœ‰ä¸åŒã€‚é¦–å…ˆAFNetworkingè¦é¢å‘æ‰€æœ‰çš„ç½‘ç»œè¯·æ±‚ï¼Œåº”è¯¥æœ‰å–æ¶ˆçš„åŠŸèƒ½ï¼Œè¿™æ—¶å¯ä»¥æ’å‡ºGCDï¼Œå…¶æ¬¡ç½‘ç»œè¯·æ±‚è¿˜æœ‰å¯èƒ½éœ€è¦æ‰¹é‡å¤„ç†ï¼Œæˆ–è€…è¯·æ±‚ä¹‹é—´æœ‰ä¾èµ–ã€æˆ–è€…å¯ä»¥è®¾ç½®çº¿ç¨‹å¹¶å‘æ•°ï¼Œè¿™æ—¶åˆå¯ä»¥æ’å‡ºNSThreadï¼Œç°åœ¨åªå‰©ä¸‹äº†NSOperationã€‚

ç°åœ¨æ¥çœ‹NSURLConnectionæ–‡ä»¶å¤¹ä¸‹ä¸‰ä¸ªç±»AFHTTPRequestOperationã€AFURLConnectionOperationã€AFHTTPRequestOperationManagerã€‚å…¶ä¸­AFHTTPRequestOperationç»§æ‰¿è‡ªAFURLConnectionOperationï¼Œè€ŒAFURLConnectionOperationåˆç»§æ‰¿è‡ªNSOperationã€‚okï¼Œç°åœ¨çœ‹åˆ°æƒ³çœ‹çš„äº†ï¼Œè¯è¯´å›æ¥NSOperationè¦æƒ³å®ç°å¹¶å‘éœ€è¦åšä»€ä¹ˆ ï¼Ÿ

éœ€è¦é‡è½½`start` `isReady` `isExecuting` `isFinished` `isConcurrent` ï¼Œç°åœ¨æ˜¯ä¸Šä»£ç çš„æ—¶å€™äº†ã€‚

{% highlight objc %}

- (BOOL)isReady {
    return self.state == AFOperationReadyState && [super isReady];
}

- (BOOL)isExecuting {
    return self.state == AFOperationExecutingState;
}

- (BOOL)isFinished {
    return self.state == AFOperationFinishedState;
}

- (BOOL)isConcurrent {
    return YES;
}

- (void)start {
    [self.lock lock];
    if ([self isCancelled]) {
        [self performSelector:@selector(cancelConnection) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    } else if ([self isReady]) {
        self.state = AFOperationExecutingState;

        [self performSelector:@selector(operationDidStart) onThread:[[self class] networkRequestThread] withObject:nil waitUntilDone:NO modes:[self.runLoopModes allObjects]];
    }
    [self.lock unlock];
}



{% endhighlight %}

ç”±ä¸Šé¢çš„ä»£ç æˆ‘ä»¬å¯ä»¥çœ‹åˆ°åœ¨startåˆé€šè¿‡performSelectorä¸å…¶å®ƒçº¿ç¨‹è¿›è¡Œé€šä¿¡ã€‚è€Œè¿™ä¸ªçº¿ç¨‹åˆæ˜¯æ€ä¹ˆæ¥çš„å‘¢ã€‚ç»§ç»­çœ‹ä»£ç 

{% highlight objc %}
+ (void)networkRequestThreadEntryPoint:(id)__unused object {
    @autoreleasepool {
        [[NSThread currentThread] setName:@"AFNetworking"];

        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];
        [runLoop run];
    }
}

+ (NSThread *)networkRequestThread {
    static NSThread *_networkRequestThread = nil;
    static dispatch_once_t oncePredicate;
    dispatch_once(&oncePredicate, ^{
        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];
        [_networkRequestThread start];
    });

    return _networkRequestThread;
}

{% endhighlight %}
åœ¨networkRequestThreadè¿™ä¸ªç±»æ–¹æ³•ä¸­åˆ›å»ºäº†ä¸€ä¸ªNSThreadçš„å•ä¾‹ï¼Œç„¶åç´§æ¥ç€å°±startäº†ã€‚è€Œåœ¨åˆå§‹åŒ–è¿™ä¸ªNSThreadçš„æ—¶å€™åˆè°ƒç”¨äº†networkRequestThreadEntryPoint ä¸»è¦ä½œç”¨å°±æ˜¯è·å–è¿™ä¸ªçº¿ç¨‹çš„currentRunLoopç»™å®ƒè®¾ç½®ä¸€ä¸ªè¾“å…¥æºNSPortï¼Œç„¶åå†runä¸€ä¸‹ï¼Œè¿™æ ·è¿™ä¸ªçº¿ç¨‹å°±ä¸€ç›´å¤„äºå·¥ä½œçŠ¶æ€ä¸é€€å‡ºã€‚è¿™ä¸ªåˆæ˜¯å¹²å•¥å‘¢ï¼Ÿ

ç»§ç»­çœ‹ä»£ç 

{% highlight objc %}

- (void)operationDidStart {
    [self.lock lock];
    if (![self isCancelled]) {
        self.connection = [[NSURLConnection alloc] initWithRequest:self.request delegate:self startImmediately:NO];

        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];
        for (NSString *runLoopMode in self.runLoopModes) {
            [self.connection scheduleInRunLoop:runLoop forMode:runLoopMode];
            [self.outputStream scheduleInRunLoop:runLoop forMode:runLoopMode];
        }

        [self.outputStream open];
        [self.connection start];
    }
    [self.lock unlock];

    dispatch_async(dispatch_get_main_queue(), ^{
        [[NSNotificationCenter defaultCenter] postNotificationName:AFNetworkingOperationDidStartNotification object:self];
    });
}

{% endhighlight %}

è¿™é‡ŒNSURLConnectionä½¿ç”¨çš„æ˜¯ä»£ç†æ¨¡å¼æ¥å›è°ƒï¼Œå¦‚æœä¸æŠŠå®ƒè®¾ç½®åˆ°runLoopä¸Šæ‰§è¡Œå®Œè¿™ä¸ªNSOperationå°±é€€å‡ºï¼Œå½“NSURLConnectionçš„è°ƒç”¨delegateçš„æ–¹æ³•æ—¶ï¼Œdelegateå·²ç»ä¸ºç©ºã€‚å°±ä¸ä¼šå‘ç”Ÿåé¢çš„äº‹äº†ã€‚æ‰€ä»¥å¿…é¡»å°†NSURLConnectionè®¾ç½®ä¸€ä¸ªNSRunLoopã€‚å¦å¤–è¿™ä¸ªrunLoopModeä¹Ÿæ˜¯ğŸˆ¶ï¸è®²ç©¶çš„ï¼Œå¿…é¡»æ˜¯NSRunLoopCommonModesï¼Œæ‰èƒ½ä¿è¯æ‰‹æœºå±å¹•åœ¨æ¥å—æ‰‹åŠ¿äº‹ä»¶çš„æ—¶å€™ï¼Œç½‘ç»œè®¿é—®ä¸å—å½±å“ã€‚å‚è€ƒ[æˆ‘å†™çš„å…³äºNSRunLoopçš„åšå®¢](http://quangelab.com/iOS-NSRunLoop/)ã€‚å¦å¤–è¯´ä¸€å¥NSRunLoopæ¥å—çš„è¾“å…¥æºåŒ…æ‹¬NSPortã€NSConnectionã€NSTimer



å¦å¤–å¦‚æœå‘é€šçŸ¥åˆç”¨GCDæ¥åˆ‡æ¢åˆ°ä¸»çº¿ç¨‹å‘é€šçŸ¥ï¼Œè¿™æ ·çœ‹ä»£ç æ¯”è¾ƒæ¸…æ™°å§
{% highlight objc %}

 dispatch_async(dispatch_get_main_queue(), ^{
            NSNotificationCenter *notificationCenter = [NSNotificationCenter defaultCenter];
            [notificationCenter postNotificationName:AFNetworkingOperationDidFinishNotification object:self];
        });

{% endhighlight %}


è¿˜æœ‰ä¸€ä¸ªæ¯”è¾ƒæœ‰è¶£çš„æ˜¯ä¸‹é¢çš„ä»£ç 

{% highlight objc %}
- (void)resume {
    if (![self isPaused]) {
        return;
    }

    [self.lock lock];
    self.state = AFOperationReadyState;

    [self start];
    [self.lock unlock];
}


- (void)setState:(AFOperationState)state {
    if (!AFStateTransitionIsValid(self.state, state, [self isCancelled])) {
        return;
    }

    [self.lock lock];
    NSString *oldStateKey = AFKeyPathFromOperationState(self.state);
    NSString *newStateKey = AFKeyPathFromOperationState(state);

    [self willChangeValueForKey:newStateKey];
    [self willChangeValueForKey:oldStateKey];
    _state = state;
    [self didChangeValueForKey:oldStateKey];
    [self didChangeValueForKey:newStateKey];
    [self.lock unlock];
}


{% endhighlight %}

çœ‹åˆ°æ²¡lockå¤šæ¬¡ï¼Œå†çœ‹lockçš„ç±»å‹æ˜¯NSRecursiveLock å³é€’å½’é”ã€‚


## æ˜¯æ—¶å€™äº®äº®iOSçš„åŒæ­¥çš„æ³•å®äº†

[æ³•å®å‡ºå¤„](https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/Multithreading/ThreadSafety/ThreadSafety.html#//apple_ref/doc/uid/10000057i-CH8-SW1)

#### åŸå­æ“ä½œï¼ˆAtomicOperationsï¼‰
åªæ”¯æŒåŸºæœ¬ç±»å‹ï¼Œæ¯”å¦‚int ä»€ä¹ˆçš„ï¼Œä¼˜ç‚¹ï¼šå¿«ã€‚å¿«åˆ°ä»€ä¹ˆç¨‹åº¦å‘¢ï¼Ÿå®ƒåœ¨ç›¸åŒçš„CPUæƒ…å†µä¸‹é€Ÿåº¦çš„æ˜¯äº’æ–¥é”çš„å››åˆ†ä¹‹ä¸€ã€‚ä½†æ˜¯ç”¨çš„æ¯”è¾ƒå°‘ï¼Œä¼—å¤šä»£ç ä¸­åœ¨RACåº“ä¸­è§åˆ°è¿‡ï¼Œåœ¨è¿™é‡Œæä¸€ä¸‹é˜²æ­¢çœ‹åˆ°ä»£ç ä¸çŸ¥é“å•¥æ„æ€å°±å°´å°¬äº†ã€‚


å¦‚RACCommandçš„ 
{% highlight objc %}
- (void)setAllowsConcurrentExecution:(BOOL)allowed {
    [self willChangeValueForKey:@keypath(self.allowsConcurrentExecution)];

    if (allowed) {
        OSAtomicOr32Barrier(1, &_allowsConcurrentExecution);
    } else {
        OSAtomicAnd32Barrier(0, &_allowsConcurrentExecution);
    }

    [self didChangeValueForKey:@keypath(self.allowsConcurrentExecution)];
}
{% endhighlight %}

#### OSMemoryBarrierå’Œvolatile

ä½œç”¨ä¸Šé¢å·²ç»è¯´äº†ï¼Œç”¨çš„ä¹Ÿæ¯”è¾ƒå°‘ï¼Œåªåœ¨RACåº“ä¸­è§è¿‡ã€‚ç”±æ­¤å¯è§RACçš„ä»£ç è¿˜æ˜¯æŒºå±Œçš„å•Š 

#### å„ç§é” Locks

æŸ¥çœ‹NSLockä»£ç å¤´æ–‡ä»¶ä¸­åˆ—äº†å››ç§NSLockã€NSConditionLockã€NSRecursiveLockã€NSConditionã€‚æ—¢ç„¶åªæœ‰è¿™å‡ ä¸ªç±»ï¼Œè¯´æ˜åªæœ‰è¿™å‡ ä¸ªå¸¸ç”¨ï¼ŒAFNetworkingä¸å°±æ˜¯ç”¨çš„NSRecursiveLocké”ä¹ˆï¼Œè™½ç„¶åœ¨ä¸Šé¢è‹¹æœå®˜æ–¹æ–‡æ¡£æˆ‘çœ‹åˆ°çš„æ˜¯Mutexã€Recursive lockã€Read-write lockã€Distributed lockã€Spin lockã€Double-checked lock



#### Conditions
å¥½å§ æˆ‘ä¹Ÿæ˜¯åªåœ¨RACä¸­è§åˆ°è¿‡

#### @synchronized

è¿™ä¸ªç”¨çš„æ¯”è¾ƒå¤šï¼Œè‹¹æœå»ºç«‹@synchronizedçš„åˆè¡·å°±æ˜¯æ–¹ä¾¿å¼€å‘è€…å¿«é€Ÿçš„å®ç°ä»£ç åŒæ­¥ï¼Œè¯­æ³•å¦‚ä¸‹ï¼š


{% highlight objc %}
@synchronized(obj) {
  //code
}
{% endhighlight %}

æœ‰äººåœ¨æµ‹è¯•é¡¹ç›®çš„main.mä¸­å†™äº†ä¸‹é¢çš„ä»£ç 

{% highlight objc %}
void testSync()
{
    NSObject* obj = [NSObject new];
    @synchronized (obj) {
    }
}
{% endhighlight %}

ç„¶ååœ¨Xcodeä¸­é€‰æ‹©èœå•Product->Perform Action->Assemble â€œmain.mâ€ï¼Œå°±å¾—åˆ°äº†å¦‚ä¸‹çš„æ±‡ç¼–ä»£ç ï¼š

![](http://cc.cocimg.com/api/uploads/20161204/1480865714265991.jpg)

_objc_sync_enterã€_objc_sync_exitè¿™ä¸¤ä¸ªå‡½æ•°åº”è¯¥å°±æ˜¯synchronizedè¿›å…¥å’Œé€€å‡ºçš„è°ƒç”¨

ä¸Šobjc-sync.mmæºç 
{% highlight objc %}
// Begin synchronizing on 'obj'. 
// Allocates recursive mutex associated with 'obj' if needed.
// Returns OBJC_SYNC_SUCCESS once lock is acquired.  
int objc_sync_enter(id obj)
{
    int result = OBJC_SYNC_SUCCESS;

    if (obj) {
        SyncData* data = id2data(obj, ACQUIRE);
        assert(data);
        data->mutex.lock();
    } else {
        // @synchronized(nil) does nothing
        if (DebugNilSync) {
            _objc_inform("NIL SYNC DEBUG: @synchronized(nil); set a breakpoint on objc_sync_nil to debug");
        }
        objc_sync_nil();
    }

    return result;
}


// End synchronizing on 'obj'. 
// Returns OBJC_SYNC_SUCCESS or OBJC_SYNC_NOT_OWNING_THREAD_ERROR
int objc_sync_exit(id obj)
{
    int result = OBJC_SYNC_SUCCESS;
    
    if (obj) {
        SyncData* data = id2data(obj, RELEASE); 
        if (!data) {
            result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;
        } else {
            bool okay = data->mutex.tryUnlock();
            if (!okay) {
                result = OBJC_SYNC_NOT_OWNING_THREAD_ERROR;
            }
        }
    } else {
        // @synchronized(nil) does nothing
    }
    

    return result;
}

typedef struct SyncData {
    struct SyncData* nextData;
    DisguisedPtr<objc_object> object;
    int32_t threadCount;  // number of THREADS using this block
    recursive_mutex_t mutex;
} SyncData;
{% endhighlight %}

synchronizedæ˜¯ä½¿ç”¨çš„é€’å½’mutexæ¥åšåŒæ­¥ã€‚

é‚£ä¹ˆ@synchronizedåé¢è·Ÿçš„å‚æ•°æ˜¯åšä»€ä¹ˆç”¨çš„å‘¢ 
çœ‹objc_sync_enter é‡Œé¢çš„ SyncData* data = id2data(obj, ACQUIRE);ï¼Œè·Ÿè¿›id2dataï¼Œçœ‹åˆ°spinlock_t *lockp = &LOCK_FOR_OBJ(object);å†è·Ÿè¿›LOCK_FOR_OBJ
{% highlight objc %}
#define LOCK_FOR_OBJ(obj) sDataLists[obj].lock
#define LIST_FOR_OBJ(obj) sDataLists[obj].data
static StripedMap<SyncList> sDataLists;

template<typename T>
class StripedMap {

    enum { CacheLineSize = 64 };

#if TARGET_OS_EMBEDDED
    enum { StripeCount = 8 };
#else
    enum { StripeCount = 64 };
#endif

    struct PaddedT {
        T value alignas(CacheLineSize);
    };

    PaddedT array[StripeCount];

    static unsigned int indexForPointer(const void *p) {
        uintptr_t addr = reinterpret_cast<uintptr_t>(p);
        return ((addr >> 4) ^ (addr >> 9)) % StripeCount;
    }

 public:
    T& operator[] (const void *p) { 
        return array[indexForPointer(p)].value; 
    }
    const T& operator[] (const void *p) const { 
        return const_cast<StripedMap<T>>(this)[p]; 
    }

#if DEBUG
    StripedMap() {
        // Verify alignment expectations.
        uintptr_t base = (uintptr_t)&array[0].value;
        uintptr_t delta = (uintptr_t)&array[1].value - base;
        assert(delta % CacheLineSize == 0);
        assert(base % CacheLineSize == 0);
    }
#endif
};


static SyncData* id2data(id object, enum usage why)
{
    spinlock_t *lockp = &LOCK_FOR_OBJ(object);
    SyncData **listp = &LIST_FOR_OBJ(object);
    SyncData* result = NULL;

#if SUPPORT_DIRECT_THREAD_KEYS
    // Check per-thread single-entry fast cache for matching object
    bool fastCacheOccupied = NO;
    SyncData *data = (SyncData *)tls_get_direct(SYNC_DATA_DIRECT_KEY);
    if (data) {
        fastCacheOccupied = YES;

        if (data->object == object) {
            // Found a match in fast cache.
            uintptr_t lockCount;

            result = data;
            lockCount = (uintptr_t)tls_get_direct(SYNC_COUNT_DIRECT_KEY);
            if (result->threadCount <= 0  ||  lockCount <= 0) {
                _objc_fatal("id2data fastcache is buggy");
            }

            switch(why) {
            case ACQUIRE: {
                lockCount++;
                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)lockCount);
                break;
            }
            case RELEASE:
                lockCount--;
                tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)lockCount);
                if (lockCount == 0) {
                    // remove from fast cache
                    tls_set_direct(SYNC_DATA_DIRECT_KEY, NULL);
                    // atomic because may collide with concurrent ACQUIRE
                    OSAtomicDecrement32Barrier(&result->threadCount);
                }
                break;
            case CHECK:
                // do nothing
                break;
            }

            return result;
        }
    }
#endif

    // Check per-thread cache of already-owned locks for matching object
    SyncCache *cache = fetch_cache(NO);
    if (cache) {
        unsigned int i;
        for (i = 0; i < cache->used; i++) {
            SyncCacheItem *item = &cache->list[i];
            if (item->data->object != object) continue;

            // Found a match.
            result = item->data;
            if (result->threadCount <= 0  ||  item->lockCount <= 0) {
                _objc_fatal("id2data cache is buggy");
            }
                
            switch(why) {
            case ACQUIRE:
                item->lockCount++;
                break;
            case RELEASE:
                item->lockCount--;
                if (item->lockCount == 0) {
                    // remove from per-thread cache
                    cache->list[i] = cache->list[--cache->used];
                    // atomic because may collide with concurrent ACQUIRE
                    OSAtomicDecrement32Barrier(&result->threadCount);
                }
                break;
            case CHECK:
                // do nothing
                break;
            }

            return result;
        }
    }

    // Thread cache didn't find anything.
    // Walk in-use list looking for matching object
    // Spinlock prevents multiple threads from creating multiple 
    // locks for the same new object.
    // We could keep the nodes in some hash table if we find that there are
    // more than 20 or so distinct locks active, but we don't do that now.
    
    lockp->lock();

    {
        SyncData* p;
        SyncData* firstUnused = NULL;
        for (p = *listp; p != NULL; p = p->nextData) {
            if ( p->object == object ) {
                result = p;
                // atomic because may collide with concurrent RELEASE
                OSAtomicIncrement32Barrier(&result->threadCount);
                goto done;
            }
            if ( (firstUnused == NULL) && (p->threadCount == 0) )
                firstUnused = p;
        }
    
        // no SyncData currently associated with object
        if ( (why == RELEASE) || (why == CHECK) )
            goto done;
    
        // an unused one was found, use it
        if ( firstUnused != NULL ) {
            result = firstUnused;
            result->object = (objc_object *)object;
            result->threadCount = 1;
            goto done;
        }
    }

    // malloc a new SyncData and add to list.
    // XXX calling malloc with a global lock held is bad practice,
    // might be worth releasing the lock, mallocing, and searching again.
    // But since we never free these guys we won't be stuck in malloc very often.
    result = (SyncData*)calloc(sizeof(SyncData), 1);
    result->object = (objc_object *)object;
    result->threadCount = 1;
    new (&result->mutex) recursive_mutex_t();
    result->nextData = *listp;
    *listp = result;
    
 done:
    lockp->unlock();
    if (result) {
        // Only new ACQUIRE should get here.
        // All RELEASE and CHECK and recursive ACQUIRE are 
        // handled by the per-thread caches above.
        if (why == RELEASE) {
            // Probably some thread is incorrectly exiting 
            // while the object is held by another thread.
            return nil;
        }
        if (why != ACQUIRE) _objc_fatal("id2data is buggy");
        if (result->object != object) _objc_fatal("id2data is buggy");

#if SUPPORT_DIRECT_THREAD_KEYS
        if (!fastCacheOccupied) {
            // Save in fast thread cache
            tls_set_direct(SYNC_DATA_DIRECT_KEY, result);
            tls_set_direct(SYNC_COUNT_DIRECT_KEY, (void*)1);
        } else 
#endif
        {
            // Save in thread cache
            if (!cache) cache = fetch_cache(YES);
            cache->list[cache->used].data = result;
            cache->list[cache->used].lockCount = 1;
            cache->used++;
        }
    }

    return result;
}


{% endhighlight %}


å¯ä»¥çœ‹åˆ° æ ¹æ®ä¼ å…¥çš„å‚æ•°ä¼šè·å–ä¸€ä¸ªspinlock_tï¼Œå†è¿›è¡Œmutexç”Ÿæˆçš„æ—¶å€™ä¼šç”¨åˆ°ï¼Œåº”è¯¥èµ·åˆ°ä¸€ä¸ªkeyçš„ä½œç”¨å§



