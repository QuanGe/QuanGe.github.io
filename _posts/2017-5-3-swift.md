---
layout: post
title: iOS装13-swift
---

### swift概述

swift 可以开发iOS, macOS, watchOS, 和 tvOS apps 。

swift目前版本3.1 

Xcode版本8.3.2

[官方The Swift Programming Language (Swift 3.1)](https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Initialization.html)

[电子书下载](http://download.csdn.net/detail/woashizhangsi/9831882)

swift语法学习可以新建一个playground项目

### Swift快速预览

swift打印hellow world不需要main函数 不需要import include，只需要一句
{% highlight swift %}
print("Hello, world!")
{% endhighlight %}

#### 简单的值

用let声明一个常量用var来声明一个变量。

{% highlight swift %}
let a: Int = Int(10.0)
var c = 20
var b: Double = 1
{% endhighlight %}

如果将浮点型赋值给整型 必须用构造的形式，Int ，如果将整型赋值给浮点型，不需要用构造，直接赋值

另外如果不做任何处理就把nil赋值给常量或变量是不允许的，必须在=前面加上?
{% highlight swift %}
let aa0: String? = nil //yes
let aa0: String = nil //no
{% endhighlight %}


字符串声明与拼接
{% highlight swift %}
let label = "The width is"
let widthLabel = label + String(c)
let helloString = "the var c = \(c) ;"
{% endhighlight %}

数组必须是指定的特殊类型，字典的key必须是hashable类型的，比如Int、String、Double、Float
{% highlight swift %}
var array = ["a","b","c"]
array[0] = "hh"
var dic = [22:111,33:22]
{% endhighlight %}

声明一个空的数组
{% highlight swift %}
var aaa = [String]() //yes
var aaa = []         //no
{% endhighlight %}

数组添加一个元素
{% highlight swift %}
aaa.append("aaa") //yes
aaa[0] = "aaa"  //no
{% endhighlight %}

数组删除一个元素
{% highlight swift %}
aaa.remove(at: 0)
{% endhighlight %}

修改一个数组的变量的值为空数组
{% highlight swift %}
aaa = []  
{% endhighlight %}

数组遍历
{% highlight swift %}
for a in aaa{
    print("\(a)")
}
{% endhighlight %}

声明一个空的字典
{% highlight swift %}
var aaa = [String: Float]() //yes
var aaa = [:]         //no
{% endhighlight %}

字典添加一个元素
{% highlight swift %}
dicEmpty.updateValue("0000", forKey: 0)  //yes
dicEmpty[1] = "222"  //yes
{% endhighlight %}

字典删除一个元素
{% highlight swift %}
dicEmpty.removeValue(forKey: 1)
{% endhighlight %}


字典遍历
{% highlight swift %}
for (a,b) in dicEmpty{
    print("\(a) \(b)")
}
{% endhighlight %}

#### 控制流

用if 和switch 做条件判断，用for in ,for ,while ,repeat-while来做作循环

先来看一个没啥变化的
{% highlight swift %}
let individualScores = [75, 43, 103, 87, 12]
var teamScore = 0
for score in individualScores {
    if score > 50 {
        teamScore += 3
    } else {
        teamScore += 1
    }
}
print(teamScore)
{% endhighlight %}


可以通过`let a = `的形式来判断一个变量是否为nil，下面两种形式同样效果
{% highlight swift %}
let aa0: String? = nil
if let a = aa0 {
    print("my name  = \(a)")
}
if aa0 != nil {
    print("my name  = \(a)")
}
{% endhighlight %}


两个`??`可以用来表示如果值为nil使用默认值
{% highlight swift %}
let nickName: String? =nil
let fullName: String = "quanGe"
let str = "hi \(nickName??fullName)"
{% endhighlight %}


switch在swift中无需使用break，程序会自动跳出，如果不想跳出可以用`，`链接使用，另外条件也可以使用let作判断条件，示例如下
{% highlight swift %}
let vegetable = "red pepper"
switch vegetable {
case "celery":
    print("Add some raisins and make ants on a log.")
case "cucumber", "watercress":
    print("That would make a good tea sandwich.")
case let x where x.hasSuffix("pepper"):
    print("Is it a spicy \(x)?")
default:
    print("Everything tastes good in soup.")
}
{% endhighlight %}

while单纯使用没什么变化，多了一个repeat,while的用法，
{% highlight swift %}
var m = 2
repeat {
    m *= 2
} while m < 100
print(m)
{% endhighlight %}

for in的时候相当于之前oc中的for(int i=0;i<5;i++)。这里需要注意`..<`不包含后面的值，`...`包含后面的值，注意是三个`.`
{% highlight swift %}
for i in 0...5{
    print("\(i)")
}
{% endhighlight %}


#### 函数和闭包

普通函数的返回值和输入参数写法与oc有所不同
{% highlight swift %}
func greet(person: String, day: String) -> String {
    return "Hello \(person), today is \(day)."
}
greet(person: "Bob", day: "Tuesday")
{% endhighlight %}

可以不写第一个参数的label，或者重命名label
{% highlight swift %}
func greet(_ person: String, on day: String) -> String {
    return "Hello \(person), today is \(day)."
}
greet("John", on: "Wednesday")
{% endhighlight %}

返回值可以不是一个值，可以是一个组合
{% highlight swift %}
func calculateStatistics(scores: [Int]) -> (min: Int, max: Int, sum: Int) {
    var min = scores[0]
    var max = scores[0]
    var sum = 0
    
    for score in scores {
        if score > max {
            max = score
        } else if score < min {
            min = score
        }
        sum += score
    }
    
    return (min, max, sum)
}
let statistics = calculateStatistics(scores: [5, 3, 100, 3, 9])
print(statistics.sum)
print(statistics.2)
{% endhighlight %}


函数参数可以是不固定参数
{% highlight swift %}
func sumOf(numbers: Int...) -> Int {
    var sum = 0
    for number in numbers {
        sum += number
    }
    return sum
}
sumOf()
sumOf(numbers: 42, 597, 12)
{% endhighlight %}

函数可以嵌套函数
{% highlight swift %}
func returnFifteen() -> Int {
    var y = 10
    func add() {
        y += 5
    }
    add()
    return y
}
returnFifteen()
{% endhighlight %}

函数可以作为返回值来返回
{% highlight swift %}
func makeIncrementer() -> ((Int) -> Int) {
    func addOne(number: Int) -> Int {
        return 1 + number
    }
    return addOne
}
var increment = makeIncrementer()
increment(7)
{% endhighlight %}

函数可以用另一个函数作为参数
{% highlight swift %}
func hasAnyMatches(list: [Int], condition: (Int) -> Bool) -> Bool {
    for item in list {
        if condition(item) {
            return true
        }
    }
    return false
}
func lessThanTen(number: Int) -> Bool {
    return number < 10
}
var numbers = [20, 19, 7, 12]
hasAnyMatches(list: numbers, condition: lessThanTen)
{% endhighlight %}


block的使用`{ in }`
{% highlight swift %}
numbers.map({ (number: Int) -> Int in
    let result = 3 * number
    return result
})
{% endhighlight %}

当变量的类型可以确定的情况下可以省略
{% highlight swift %}
numbers.map({ number in 3 * number
})
{% endhighlight %}

你可以用数字来替代变量。当block当作仅有的一个参数时`()`可以省略
{% highlight swift %}
let sortedNumbers = numbers.sorted { $0 > $1 }
print(sortedNumbers)
{% endhighlight %}


#### 类和对象
类中的property和上面的变量一样声明。常量用let。创建一个对象用类名加上`()`，如果init函数有其他参数，可以在类名后面的`()`里面加上参数。访问一个类的property和方法都用`.`
{% highlight swift %}
class EquilateralTriangle: NamedShape {
    var sideLength: Double = 0.0
    
    init(sideLength: Double, name: String) {
        self.sideLength = sideLength
        super.init(name: name)
        numberOfSides = 3
    }
    
    var perimeter: Double {
        get {
            return 3.0 * sideLength
        }
        set {
            sideLength = newValue / 3.0
        }
    }
    
    override func simpleDescription() -> String {
        return "An equilateral triangle with sides of length \(sideLength)."
    }
}
var triangle = EquilateralTriangle(sideLength: 3.1, name: "a triangle")
print(triangle.perimeter)
triangle.perimeter = 9.9
print(triangle.sideLength)
{% endhighlight %}

`willSet` 和 `didSet`可以在property的值发生改变之前或之后调用，除了初始化值以外。
{% highlight swift %}
class TriangleAndSquare {
    var triangle: EquilateralTriangle {
        willSet {
            square.sideLength = newValue.sideLength
        }
    }
    var square: Square {
        willSet {
            triangle.sideLength = newValue.sideLength
        }
    }
    init(size: Double, name: String) {
        square = Square(sideLength: size, name: name)
        triangle = EquilateralTriangle(sideLength: size, name: name)
    }
}
var triangleAndSquare = TriangleAndSquare(size: 10, name: "another test shape")
print(triangleAndSquare.square.sideLength)
print(triangleAndSquare.triangle.sideLength)
triangleAndSquare.square = Square(sideLength: 50, name: "larger square")
print(triangleAndSquare.triangle.sideLength)
{% endhighlight %}


当需要的东西可以是nil时，你可以在操作方法属性脚标之前写`?`，当`?`之前的东西是nil时，后面的操作就忽略了，如果你不加`？`，但是你的值是nil，则会crash掉哦。

#### 枚举和Structures 
用`enum`来创建一个枚举。与oc不同的是，枚举也可以有方法。
{% highlight swift %}
enum Rank: Int {
    case ace = 1
    case two, three, four, five, six, seven, eight, nine, ten
    case jack, queen, king
    func simpleDescription() -> String {
        switch self {
        case .ace:
            return "ace"
        case .jack:
            return "jack"
        case .queen:
            return "queen"
        case .king:
            return "king"
        default:
            return String(self.rawValue)
        }
    }
}
let ace = Rank.ace
let aceRawValue = ace.rawValue
{% endhighlight %}

利用`init?(rawValue:)`的形式创建一个枚举对象,例如
{% highlight swift %}
if let convertedRank = Rank(rawValue: 3) {
    let threeDescription = convertedRank.simpleDescription()
}
{% endhighlight %}


struct和class用法一样，唯一不同的是struct类型的对象赋值给另外一个变量的时候是拷贝，而class类型的对象则是引用计数加一



#### 协议和扩展
利用protocol来声明一个协议 
与oc不同的是struct和class 枚举都可以继承协议，只有class在修改实例变量的时候不需要mutating，其他均需要，所以一般如果协议中要定义某个方法时，如果这个协议不只针对class，最好加上mutating
{% highlight swift %}
protocol ExampleProtocol {
    var simpleDescription: String { get }
    mutating func adjust()
}
class SimpleClass: ExampleProtocol {
    var simpleDescription: String = "A very simple class."
    var anotherProperty: Int = 69105
    func adjust() {
        simpleDescription += "  Now 100% adjusted."
    }
}
var a = SimpleClass()
a.adjust()
let aDescription = a.simpleDescription
 
struct SimpleStructure: ExampleProtocol {
    var simpleDescription: String = "A simple structure"
    mutating func adjust() {
        simpleDescription += " (adjusted)"
    }
}
var b = SimpleStructure()
b.adjust()
let bDescription = b.simpleDescription
{% endhighlight %}

extension 和oc的category用法一样，用来扩展已有的类，加上一些方法
{% highlight swift %}
extension Int: ExampleProtocol {
    var simpleDescription: String {
        return "The number \(self)"
    }
    mutating func adjust() {
        self += 42
    }
}
print(7.simpleDescription)
{% endhighlight %}

#### 错误捕捉
如果你要自定义一些错误枚举类型，需要继承自Error协议
{% highlight swift %}
enum PrinterError: Error {
    case outOfPaper
    case noToner
    case onFire
}
{% endhighlight %}


用`throw`可以抛出异常，用`throws`来标记一个函数可以抛出异常
{% highlight swift %}
func send(job: Int, toPrinter printerName: String) throws -> String {
    if printerName == "Never Has Toner" {
        throw PrinterError.noToner
    }
    return "Job sent"
}
{% endhighlight %}

你可以使用do-catch来捕获异常，在do的代码块中，你把try放在可以抛异常的函数前面。在catch的代码块中，如果你不指定一个特别的名字，那么自动为error。
{% highlight swift %}
do {
    let printerResponse = try send(job: 1040, toPrinter: "Bi Sheng")
    print(printerResponse)
} catch {
    print(error)
}
{% endhighlight %}

当然你也可以写不同的代码catch代码块来捕捉不同的错误。例如
{% highlight swift %}
do {
    let printerResponse = try send(job: 1440, toPrinter: "Gutenberg")
    print(printerResponse)
} catch PrinterError.onFire {
    print("I'll just put this over here, with the rest of the fire.")
} catch let printerError as PrinterError {
    print("Printer error: \(printerError).")
} catch {
    print(error)
}
{% endhighlight %}

#### 范型
比如有个这样的需求，写一段代码可以构造出任意类型的数组，用oc可以很容易，直接用NSArray就可以，但是在swift中，类型一经指定不可改变。这就需要范型
{% highlight swift %}
func makeArray<Item>(repeating item: Item, numberOfTimes: Int) -> [Item] {
    var result = [Item]()
    for _ in 0..<numberOfTimes {
        result.append(item)
    }
    return result
}
makeArray(repeating: "knock", numberOfTimes:4)

{% endhighlight %}

范型可以应用在class、struct、枚举、方法、函数中
{% highlight swift %}
// Reimplement the Swift standard library's optional type
enum OptionalValue<Wrapped> {
    case none
    case some(Wrapped)
}
var possibleInteger: OptionalValue<Int> = .none
possibleInteger = .some(100)
{% endhighlight %}

在代码块之前写where可以加一些过滤条件例如需要这种类型必须继承自某协议或者两种类型相同、或者需要这种类型有个特定的父类
{% highlight swift %}
func anyCommonElements<T: Sequence, U: Sequence>(_ lhs: T, _ rhs: U) -> Bool
    where T.Iterator.Element: Equatable, T.Iterator.Element == U.Iterator.Element {
        for lhsItem in lhs {
            for rhsItem in rhs {
                if lhsItem == rhsItem {
                    return true
                }
            }
        }
        return false
}
anyCommonElements([1, 2, 3], [3])
{% endhighlight %}


